/* A network interface. This is required by the azurerm_virtual_machine 
resource. Terraform will let you know if you're missing a dependency. */

resource "azurerm_network_interface" "vault-nic" {
  name                      = "${var.prefix}-vault-nic"
  location                  = "${var.location}"
  resource_group_name       = "${azurerm_resource_group.hashitraining.name}"
  network_security_group_id = "${azurerm_network_security_group.vault-sg.id}"

  ip_configuration {
    name                          = "${var.prefix}ipconfig"
    subnet_id                     = "${azurerm_subnet.subnet.id}"
    private_ip_address_allocation = "Dynamic"
    public_ip_address_id          = "${azurerm_public_ip.vault-pip.id}"
  }
}

/* Every Azure Virtual Machine comes with a private IP address. You can also 
optionally add a public IP address for Internet-facing applications and 
demo environments like this one. */

resource "azurerm_public_ip" "vault-pip" {
  name                = "${var.prefix}-ip"
  location            = "${var.location}"
  resource_group_name = "${azurerm_resource_group.hashitraining.name}"
  allocation_method   = "Dynamic"
  domain_name_label   = "${var.prefix}"
}

/* And finally we build our Vault server. This is a standard Ubuntu instance.
We use the shell provisioner to run a Bash script that configures Vault for 
the demo environment. Terraform supports several different types of 
provisioners including Bash, Powershell and Chef. */

resource "azurerm_virtual_machine" "vault" {
  name                = "${var.prefix}-vault"
  location            = "${var.location}"
  resource_group_name = "${azurerm_resource_group.hashitraining.name}"
  vm_size             = "${var.vm_size}"

  network_interface_ids         = ["${azurerm_network_interface.vault-nic.id}"]
  delete_os_disk_on_termination = "true"

  storage_image_reference {
    publisher = "${var.image_publisher}"
    offer     = "${var.image_offer}"
    sku       = "${var.image_sku}"
    version   = "${var.image_version}"
  }

  storage_os_disk {
    name              = "${var.prefix}-osdisk"
    managed_disk_type = "StandardSSD_LRS"
    caching           = "ReadWrite"
    create_option     = "FromImage"
  }

  os_profile {
    computer_name  = "${var.prefix}"
    admin_username = "${var.admin_username}"
    admin_password = "${var.admin_password}"
  }

  os_profile_linux_config {
    disable_password_authentication = false
  }

   provisioner "file" {
     source      = "files/"
     destination = "/home/${var.admin_username}/"

     connection {
       type     = "ssh"
       user     = "${var.admin_username}"
       password = "${var.admin_password}"
       host     = "${azurerm_public_ip.vault-pip.fqdn}"
     }
   }

  provisioner "remote-exec" {
    inline = [
      "chmod -R +x /home/${var.admin_username}/*",
      "sleep 30",
      "MYSQL_HOST=${var.prefix}-mysql-server /home/${var.admin_username}/setup.sh"
    ]

    connection {
      type     = "ssh"
      user     = "${var.admin_username}"
      password = "${var.admin_password}"
      host     = "${azurerm_public_ip.vault-pip.fqdn}"
    }
  }
}

/* Public IP addresses are not generated until they are attached to an object.
So we use a 'data source' here to fetch it once its available. Then we can
provide the public IP address to the next resource for allowing firewall 
access to our database. */

data "azurerm_public_ip" "vault-pip" {
  name                = "${azurerm_public_ip.vault-pip.name}"
  depends_on          = ["azurerm_virtual_machine.vault"]
  resource_group_name = "${azurerm_virtual_machine.vault.resource_group_name}"
}


